# ********************************************************************
# Name    : Node MO Selection
# Summary : Used by node pool manager during node allocation.
#           Used as part of node allocation if the profile requesting
#           nodes, has a cell cardinality value attribute, some
#           profiles read the cardinality
#           files generated by nss_mo_info.py module, filters and
#           selects nodes supplied against those which meet the
#           cardinality requirements.
# ********************************************************************

import json

from enmutils.lib import filesystem, log
from enmutils.lib.exceptions import EnvironError
from enmutils_int.lib.network_mo_info import CARDINALITY_FILE, MO_FILE


class NodeMoSelection(object):

    def __init__(self):
        """
        Init method
        """
        self.cardinality_information = {}
        self.mo_information = {}

    @staticmethod
    def read_information_from_file(file_in):
        """
        Read the information from file

        :param file_in: File path of the file to be read
        :type file_in: str

        :raises EnvironError: raised if the file read fails or the file is empty

        :return: Dictionary containing the file content
        :rtype: dict
        """
        log.logger.debug("Starting read of node(s) file.")
        try:
            file_data = filesystem.get_lines_from_file(file_in)
            if not file_data:
                raise EnvironError("No file data found: {0}, please ensure the {1} information has generated "
                                   "correctly.".format(file_data, file_in))
            log.logger.debug("Completed read of node(s) cardinality file.")
            return json.loads(file_data[0], object_hook=byteify)
        except Exception as e:
            raise EnvironError(str(e))

    def read_cardinality_information_from_file(self):
        """
        Read the cardinality information from file
        """
        log.logger.debug("Starting read of node(s) cardinality file.")

        self.cardinality_information = self.read_information_from_file(CARDINALITY_FILE)
        log.logger.debug("Completed read of node(s) cardinality file.")

    def read_mo_information_from_file(self):
        """
        Read the MO information from file
        """
        log.logger.debug("Starting read of node(s) MO file.")

        self.mo_information = self.read_information_from_file(MO_FILE)
        log.logger.debug("Completed read of node(s) Mo file.")

    def select_all_with_required_mo_cardinality(self, mo_name, min_cardinality=None, max_cardinality=None, nodes=None):
        """
        Filter nodes or node names for a MO with a defined volume

        :param mo_name: Name of the MO to query for cardinality
        :type mo_name: str
        :param min_cardinality: Minimum number of MOs to be present on the node
        :type min_cardinality: int
        :param max_cardinality: Maximum number of MOs to be present on the node
        :type max_cardinality: int
        :param nodes: List of `enm_node.Node` objects
        :type nodes: list

        :return: List of node name or matched node objects
        :rtype: list
        """
        matched_node_ids = []
        log.logger.debug("Selecting nodes with required cardinality.")
        if not self.cardinality_information:
            self.read_cardinality_information_from_file()
        for key, value in self.cardinality_information.iteritems():
            if mo_name in value.keys() and self.check_cardinality_meets_requirement(
                    mo_cardinality=int(value.get(mo_name)), min_cardinality=min_cardinality,
                    max_cardinality=max_cardinality):
                matched_node_ids.append(key)
        log.logger.debug("Completed selecting nodes with required cardinality.")
        return matched_node_ids if not nodes else [node for node in nodes if node.node_name in matched_node_ids]

    @staticmethod
    def check_cardinality_meets_requirement(mo_cardinality, min_cardinality=None, max_cardinality=None):
        """
        Confirm the MO cardinality is within the requirement

        :param mo_cardinality: Existing number of MOs present on the node
        :type mo_cardinality: int
        :param min_cardinality: Minimum number of MOs to be present on the node
        :type min_cardinality: int
        :param max_cardinality: Maximum number of MOs to be present on the node
        :type max_cardinality: int
        :return: Boolean indicating if the node meets the requirement
        :rtype: bool
        """
        if max_cardinality and min_cardinality:
            result = min_cardinality <= mo_cardinality <= max_cardinality
        elif min_cardinality:
            result = min_cardinality <= mo_cardinality
        else:
            result = mo_cardinality <= max_cardinality
        return result

    def get_available_mo_values(self, mo_name, nodes=None):
        """
        Query the MO dictionary for matching MOs

        ::param mo_name: Name of the MO to query for cardinality
        :type mo_name: str
        :param nodes: List of `enm_node.Node` objects
        :type nodes: list

        :return: Dictionary containing dictionary of MO/Mo values per matched node name
        :rtype: dict
        """
        mos_found = {}
        log.logger.debug("Starting check for matching Mos.")
        if not self.mo_information:
            self.read_mo_information_from_file()
        if nodes:
            for node in nodes:
                node_name = node.node_name
                if (node_name in self.mo_information.iterkeys() and mo_name in
                        self.mo_information.get(node_name).iterkeys()):
                    mos_found[node_name] = {}
                    mos_found[node_name][mo_name] = self.mo_information.get(node_name).get(mo_name)
        else:
            for key, value in self.mo_information.iteritems():
                if mo_name in value.iterkeys():
                    mos_found[key] = {}
                    mos_found[key][mo_name] = self.mo_information.get(key).get(mo_name)
        log.logger.debug("Completed check for matching Mos.")
        return mos_found


def byteify(json_input):
    """
    Convert json.loads from unicode to str
    https://stackoverflow.com/questions/956867/how-to-get-string-objects-instead-of-unicode-from-json

    :param json_input: Object to be passed to json.loads, should be str or buffer
    :type json_input: object
    :return: Updated input value
    :rtype: object
    """
    if isinstance(json_input, dict):
        return {byteify(key): byteify(value)
                for key, value in json_input.iteritems()}
    elif isinstance(json_input, list):
        return [byteify(element) for element in json_input]
    elif isinstance(json_input, unicode):
        return json_input.encode('utf-8')
    else:
        return json_input
