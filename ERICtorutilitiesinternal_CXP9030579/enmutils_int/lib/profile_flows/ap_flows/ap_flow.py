import re
import time

from retrying import retry

from enmutils.lib import log
from enmutils.lib.enm_node import Node, RadioNode
from enmutils.lib.exceptions import (EnmApplicationError, EnvironError,
                                     NoNodesAvailable)
from enmutils.lib.persistence import picklable_boundmethod
from enmutils_int.lib import load_mgr
from enmutils_int.lib.amos_executor import \
    check_ldap_is_configured_on_radio_nodes
from enmutils_int.lib.auto_provision import AutoProvision
from enmutils_int.lib.auto_provision_project import (Project,
                                                     scp_upgrade_packages)
from enmutils_int.lib.profile_flows.common_flows.common_flow import GenericFlow
from enmutils_int.lib.enm_user import get_workload_admin_user

REQUIRED_LICENSE = "Radio_Network_Base_Package_numberOf_5MHzSC"
LICENSE_TEXT = "License permission check failed"
FDN_KEY = "FDN"


class ApFlow(GenericFlow):

    AP_PROJECT = 'project1'
    NODE_ID_1 = "AP_SetupProfile_01"
    NODE_ID_2 = "AP_SetupProfile_02"
    objects_list = list()

    def download_artifact(self, auto, node=None, artifact=None, ordered=False):
        """
        Downloads the artifact generated by auto provision

        :type auto: `auto_provision.AutoProvision`
        :param auto: Instance of the AutoProvision class
        :type node: `enm_node.Node`
        :param node: Node object to be integrated
        :type artifact: str
        :param artifact: Artifact to download if required
        :type ordered: bool
        :param ordered: Flag indicating whether or not to down the ordered node artifact
        """
        try:
            auto.download_artifacts(node=node, artifact=artifact, ordered=ordered)
        except Exception as e:
            self.add_error_as_exception(e)

    def execute_flow(self):
        """
        Executes the profile flow
        """
        load_mgr.wait_for_setup_profile("AP_SETUP", state_to_wait_for="COMPLETED")
        self.state = "RUNNING"
        users = self.create_profile_users(self.NUM_USERS, self.USER_ROLES)
        self.create_auto_provision_instances(users)
        while self.keep_running():
            self.create_and_execute_threads(self.objects_list, len(self.objects_list), args=[self])
            self.sleep()

    def create_auto_provision_instances(self, users):
        """
        Creates an auto provision instance for each user

        :param users: List of enm user objects
        :type users: list
        """
        for user in users:
            auto = AutoProvision(user=user, project_name=self.AP_PROJECT)
            self.objects_list.append(auto)


class ApSetupFlow(ApFlow):

    def execute_flow(self):
        """
        Executes the flow for the profile
        """
        self.state = "RUNNING"
        user = self.create_profile_users(1, ["ADMINISTRATOR"])[0]
        nodes = [ApSetupRadioNode(node_id=self.NODE_ID_1, node_ip="{0}.{1}.{2}.{3}".format(11, 2, 33, 4),
                                  model_identity="18.Q4-R57A02", primary_type="RadioNode", subnetwork="SubNetwork1",
                                  user="netsim", passwd="netsim"),
                 ApSetupRadioNode(node_id=self.NODE_ID_2, node_ip="{0}.{1}.{2}.{3}".format(1, 22, 3, 55),
                                  model_identity="18.Q4-R57A02", primary_type="RadioNode", subnetwork="SubNetwork1",
                                  user="netsim", passwd="netsim")]
        scp_upgrade_packages()
        project = Project(user=user, name=self.AP_PROJECT, description="Sample project", nodes=nodes)
        auto = AutoProvision(user, project_name=self.AP_PROJECT)
        self.teardown_list.append(picklable_boundmethod(auto.delete_project))
        if not auto.exists():
            self.delete_setup_nodes(user, auto, nodes, poll=False)
            try:
                project.create_project()
                self.teardown_list.append(project)
                auto.import_project("{0}.zip".format(self.AP_PROJECT))
                sleep_time = 120
                log.logger.debug("Sleeping for {0} seconds to allow order to complete.".format(sleep_time))
                time.sleep(sleep_time)
                self.delete_setup_nodes(user, auto, nodes)
            except Exception as e:
                self.add_error_as_exception(EnmApplicationError(str(e)))
        else:
            log.logger.debug("Auto Provision Project already exists in ENM, nothing to do.")

    @staticmethod
    def delete_setup_nodes(user, auto, nodes, poll=True):
        """
        Delete the supplied nodes from ENM, optional polling for recently ordered nodes.

        :param user: User who make the ENM requests
        :type user: `enm_user_2.User`
        :param auto: Auto Provision instance to perform the delete operation
        :type auto: `auto_provision.AutoProvision`
        :param nodes: List of node instances to be deleted
        :type nodes: list
        :param poll: Boolean indicating if the user should poll for the nodes to be available in ENM
        :type poll: bool
        """
        log.logger.debug("Attempting to delete AP Setup nodes.")
        for node in nodes:
            try:
                if poll:
                    auto.poll_until_enm_can_retrieve_network_element(node)
                auto.disable_supervision_and_delete_node(user, node)
            except Exception as e:
                log.logger.debug("Issue encountered attempting to delete setup nodes: {0}".format(str(e)))
                continue


class Ap01Flow(ApFlow):

    auto = None
    PROJECT_TEARDOWN_CHECK = False
    AUTO_TEARDOWN_CHECK = False

    def execute_flow(self):
        """
        Executes the flow for the profile
        """
        self.state = "RUNNING"

        users = self.create_profile_users(self.NUM_USERS, roles=self.USER_ROLES)
        self.user = users[0]  # pylint: disable=attribute-defined-outside-init

        nodes = self.get_nodes_list_by_attribute(
            node_attributes=["node_id", "primary_type", "node_name", "node_ip", "subnetwork", "subnetwork_id",
                             "model_identity", "secure_user", "secure_password", "mim_version", "oss_prefix"])
        try:
            check_ldap_is_configured_on_radio_nodes(self, self.user, nodes, self.PROJECT_NAME)
            project = Project(self.PROJECT_NAME, self.user)
            for node in nodes:
                node.model_identity = project.get_model_id(node)
                node.secure_user, node.secure_password = project.get_node_secure_username_and_password(node)
                log.logger.debug("Node: {0}, model_identity: {1}, secure_user: {2}, secure_password: {3}"
                                 .format(node.node_id, node.model_identity, node.secure_user, node.secure_password))
        except Exception as e:
            self.add_error_as_exception(EnvironError(e))
        while self.keep_running():
            self.sleep_until_time()
            try:
                scp_upgrade_packages()
                self.create_auto_provisioning_project(nodes)
            except Exception as e:
                self.add_error_as_exception(e)

    def create_auto_provisioning_project(self, nodes):
        """
        creates auto provisioning project as many times as NUM_ITERATIONS value
        :param nodes: List of Load node objects to be included in the project
        :type nodes: list
        """
        for i in range(0, self.NUM_ITERATIONS):
            try:
                log.logger.debug('Starting iteration {0} of {1}'.format(i + 1, self.NUM_ITERATIONS))
                self.auto_provisioning_project_setup(nodes)
                try:
                    for node in self.auto.nodes:
                        self.node_up_task(node)
                except EnmApplicationError as e:
                    self.add_error_as_exception(e)
                # Give ENM time to complete the integration
                response = None
                max_tries = 5
                for _ in range(max_tries):
                    response = self.auto.status()
                    response_list = response[1].split('\t')
                    if response_list[4] == str(len(nodes)):
                        log.logger.debug('Completed the nodes Integration')
                        break
                    else:
                        log.logger.debug('Sleep for 2 minutes to allow nodes status to change to integrated')
                        time.sleep(120)
                else:
                    self.add_error_as_exception(EnmApplicationError("Nodes couldn't integrate, "
                                                                    "status - {0}".format("\n".join(response))))
                    self.handle_node_integration_failure(response, nodes)
                self.delete_project(self.auto)
                self.update_nodes_with_poid_info()
            except Exception as e:
                self.add_error_as_exception(e)

    def handle_node_integration_failure(self, response, nodes):
        """
        If node integration is incomplete, we create those nodes and add them back into ENM
        :param response: response of nodes status
        :type response: list
        :param nodes: List of Load node objects to be included in the project
        :type nodes: list

        :raises EnvironError: raised if integration failed nodes were not added back to ENM
        :raises EnmApplicationError: raised if no ldap configured radionodes found
        """
        log.logger.debug("Nodes didn't move to 'Integration Completed' state. Response - {0}".format(response))
        node_status_list = response[3:]
        failed_node_names = []
        for node_status in node_status_list:
            if "Integration Completed" not in node_status and len(node_status.split('\t')[0]) > 0:
                failed_node_names.append(node_status.split('\t')[0])
        failed_nodes = [node for node in nodes if node.node_name in failed_node_names]
        for node in failed_nodes:
            log.logger.debug("Adding the node - {0} back to ENM".format(node.node_name))
            self.auto.create_and_supervise_node(node)
        try:
            check_ldap_is_configured_on_radio_nodes(self, self.user, nodes, self.PROJECT_NAME)
        except Exception as e:
            raise EnmApplicationError("Problem Encountered when configuring LDAP on nodes. Exception: {0}".format(e))
        nodes_on_enm = verify_nodes_on_enm(failed_nodes)
        if len(nodes_on_enm) == len(failed_nodes):
            log.logger.debug("Successfully added failed nodes to ENM")
        else:
            not_added_nodes = list(set(failed_node_names) - set(nodes_on_enm))
            log.logger.debug("Unable to add these nodes back to ENM: {0}".format(not_added_nodes))
            raise EnvironError("Failed to add missing nodes back to ENM")

    def auto_provisioning_project_setup(self, nodes):
        """
        :param nodes: List of Load node objects to be included in the project
        :type nodes: list
        :raises EnmApplicationError: raised if import fails
        """
        try:
            self.auto = self.prepare_auto_provision_project(nodes)
            log.logger.debug("Sleep for 3 minutes to allow nodes to be fully deleted from ENM database")
            time.sleep(180)
            self.import_auto_provision_project(self.auto)
            max_tries = 5
            for _ in range(max_tries):
                response = self.auto.status()
                response_list = response[3].split()
                if 'Completed' in response_list:
                    log.logger.debug('Nodes Status changed to ordered')
                    break
                else:
                    # Give ENM time to complete the order
                    log.logger.debug('Sleep for 1 minute to allow nodes status to change to ordered')
                    time.sleep(60)
            for node in self.auto.nodes:
                self.download_artifact(self.auto, node=node)
        except Exception as e:
            if "Import project failed after multiple retries.." in e:
                raise EnmApplicationError(e)
            self.add_error_as_exception(e)

    def prepare_auto_provision_project(self, nodes):
        """
        Create the Auto Provision project and instance which will interact with ENM

        :param nodes: List of Load node objects to be included in the project
        :type nodes: list

        :return: The Auto Provision instance created
        :rtype: `auto_provision.AutoProvision`
        """
        auto = None
        while not auto:
            try:
                project = self.create_project(nodes, user=self.user)
                if not project:
                    self.add_error_as_exception(NoNodesAvailable("No available nodes to create project, "
                                                                 "will retry in one hour."))
                    time.sleep(3600)
                    continue
                auto = AutoProvision(user=self.user, project_name=self.PROJECT_NAME, nodes=project.nodes, profile=self)
            except Exception as e:
                log.logger.debug("Unable to create auto provision object, error encountered: {0}, "
                                 "will retry in one hour.".format(str(e)))
                self.add_error_as_exception(e)
                time.sleep(3600)
        if not self.AUTO_TEARDOWN_CHECK:
            self.teardown_list.append(picklable_boundmethod(auto._teardown))
            self.AUTO_TEARDOWN_CHECK = True
        self.delete_project_nodes(nodes, self.user)
        return auto

    @retry(retry_on_exception=lambda e: isinstance(e, EnmApplicationError), wait_fixed=120000,
           stop_max_attempt_number=3)
    def import_auto_provision_project(self, auto):
        """
        Import the supplied auto provision project

        :type auto: `auto_provision.AutoProvision`
        :param auto: Instance of the AutoProvision class

        :raises EnmApplicationError: raised if existence of autoprovision instance fails after 12 retries
        """

        if auto.exists():
            self.delete_project(auto)
        retry_count = 0
        while not auto.exists():
            retry_count = retry_count + 1
            if retry_count == 4:
                raise EnmApplicationError("Import project failed after multiple retries..")
            try:
                # Use Case id: AP_01  and Use Case id: AP_03
                auto.import_project("{0}.zip".format(self.PROJECT_NAME))
            except Exception as e:
                self.add_error_as_exception(EnmApplicationError(e.message))
                continue

    def delete_project(self, auto):
        """
        Delete the provided auto project, including nodes

        :type auto: `auto_provision.AutoProvision`
        :param auto: Instance of the AutoProvision class
        """
        while auto.exists():
            for node in auto.nodes:
                try:
                    auto.delete_project(node=node)
                except Exception as e:
                    self.add_error_as_exception(e)
            if auto.exists():
                try:
                    auto.delete_project()
                    if auto in self.teardown_list:
                        self.teardown_list.remove(auto)
                except Exception as e:
                    self.add_error_as_exception(e)

    def delete_project_nodes(self, nodes, user):
        """
        Delete nodes from ENM deployment before we try to use them

        :type nodes: list
        :param nodes: List of `enm_node.Node` objects to be deleted from ENM
        :type user: `enm_user_2.User`
        :param user: Enm user who will perform the deletion
        """
        auto = AutoProvision(nodes=nodes, user=user)
        success = False
        retry = 0
        while not success and retry < 5:
            try:
                auto.delete_nodes_from_enm(nodes=nodes, user=user)
                success = True
            except Exception as e:
                log.logger.debug("Failed to delete all nodes, sleeping for 60 seconds before retrying. Response: {0}"
                                 .format(e.message))
                self.add_error_as_exception(e)
                retry += 1
                time.sleep(60)
                continue

    def create_project(self, nodes, user):
        """
        Create the auto provision project to use, based on our current index of iteration, and map the available nodes

        :rtype: `auto_provision_project.Project`
        :return: Project that will be imported
        """
        ap_project = Project(self.PROJECT_NAME, user=user, nodes=nodes,
                             description="AP_01 Workload project description")
        project = None
        iteration = 1
        while not project and iteration < 5:
            try:
                ap_project.create_project()
                if not self.PROJECT_TEARDOWN_CHECK:
                    self.teardown_list.append(picklable_boundmethod(ap_project.delete_scripts_copied_remote_host))
                    self.teardown_list.append(ap_project)
                    self.PROJECT_TEARDOWN_CHECK = True
                project = ap_project
            except Exception as e:
                self.add_error_as_exception(e)
                time.sleep(60)
                log.logger.debug("Failed to correctly create project for use by auto provision, retrying in 60 "
                                 "seconds.")
                iteration += 1
        return project

    def node_up_task(self, node):
        """
        Checks status of the project in UI and sends node-up for nodes

        :type node: `enm_node.Node`
        :param node: Node object to be integrated

        :raises EnmApplicationError: raised if there is license issue.
        """
        try:
            response = self.auto.status(node=node)
            response_check = [re.search(r'\s*failed\s*', value, re.I) for value in response]
            if any(response_check):
                response_fail = [value.group(0).encode('utf-8') for value in response_check if value]
                self.add_error_as_exception(
                    EnmApplicationError("Node has failed to order correctly, order status: {0}".format(response_fail)))
            else:
                try:
                    self.download_artifact(self.auto, node=node, ordered=True)
                except Exception as e:
                    self.add_error_as_exception(e)
                self.auto.integrate_node(node=node)
        except Exception as e:
            if LICENSE_TEXT in e:
                log.logger.debug("Project failed due to no valid license. Check and re-install the required license")
                log.logger.debug("Required license is: {0}".format(REQUIRED_LICENSE))
                raise EnmApplicationError(e)
            self.add_error_as_exception(e)


class Ap11Flow(ApFlow):

    @staticmethod
    def task_set(worker, profile):
        """
        Performs a task on the cli application via the AutoProvision Object

        :param worker:  instance to be used to perform the flow
        :type worker: `auto_provision.AutoProvision`
        :type profile: `flowprofile.FlowProfile`
        :param profile: Profile to add errors to
        """
        try:
            worker.view(view_all=True, timeout=5 * 60)
        except Exception as e:
            profile.add_error_as_exception(e)


class Ap12Flow(ApFlow):

    @staticmethod
    def task_set(worker, profile):
        """
        Performs a task on the cli application via the AutoProvision Object

        :param worker:  instance to be used to perform the flow
        :type worker: `auto_provision.AutoProvision`
        :type profile: `flowprofile.FlowProfile`
        :param profile: Profile to add errors to
        """
        try:
            worker.view()
        except Exception as e:
            profile.add_error_as_exception(e)


class Ap13Flow(ApFlow):

    @staticmethod
    def task_set(worker, profile):
        """
        Performs a task on the cli application via the AutoProvision Object

        :param worker:  instance to be used to perform the flow
        :type worker: `auto_provision.AutoProvision`
        :type profile: `flowprofile.FlowProfile`
        :param profile: Profile to add errors to
        """
        node = Node(node_id=profile.NODE_ID_1)
        try:
            worker.view(node=node, timeout=540)
        except Exception as e:
            profile.add_error_as_exception(e)


class Ap14Flow(ApFlow):

    objects_list = list()

    @staticmethod
    def task_set(worker, profile):
        """
        Performs a task on the cli application via the AutoProvision Object

        :param worker:  instance to be used to perform the flow
        :type worker: `auto_provision.AutoProvision`
        :type profile: `flowprofile.FlowProfile`
        :param profile: Profile to add errors to
        """
        try:
            worker.status(status_all=True, timeout=240)
        except Exception as e:
            profile.add_error_as_exception(e)


class Ap15Flow(ApFlow):

    @staticmethod
    def task_set(worker, profile):
        """
        Performs a task on the cli application via the AutoProvision Object

        :param worker:  instance to be used to perform the flow
        :type worker: `auto_provision.AutoProvision`
        :type profile: `flowprofile.FlowProfile`
        :param profile: Profile to add errors to
        """
        try:
            worker.status()
        except Exception as e:
            profile.add_error_as_exception(e)


class Ap16Flow(ApFlow):

    @staticmethod
    def task_set(worker, profile):
        """
        Performs a task on the cli application via the AutoProvision Object

        :param worker:  instance to be used to perform the flow
        :type worker: `auto_provision.AutoProvision`
        :type profile: `flowprofile.FlowProfile`
        :param profile: Profile to add errors to
        """
        node = Node(node_id=profile.NODE_ID_2)
        try:
            worker.status(node=node, timeout=90)
        except Exception as e:
            profile.add_error_as_exception(e)


class ApSetupRadioNode(RadioNode):

    @property
    def node_name(self):
        """
        Override the property as the node id contains underscores
        :returns: Unaltered node_id value, parent will split on underscores
        :rtype: str
        """
        return self.node_id


def verify_nodes_on_enm(nodes):
    """
    Verify the list of supplied node ids exist on ENM

    :param nodes: List of nodes to confirm if they are created on ENM
    :type nodes: list

    :raises EnmApplicationError: raised if the command fails to execute correctly

    :returns: List of nodes created in ENM
    :rtype: list
    """
    cmd = "cmedit get {0} NetworkElement".format(";".join([node.node_id for node in nodes]))
    nes_on_enm = []
    try:
        admin_user = get_workload_admin_user()
        response = admin_user.enm_execute(cmd).get_output()
        for line in response:
            if FDN_KEY in line:
                nes_on_enm.append(line.split("=")[-1].strip().encode('utf-8'))
        return list(set(nes_on_enm))
    except Exception as e:
        raise EnmApplicationError(str(e))
