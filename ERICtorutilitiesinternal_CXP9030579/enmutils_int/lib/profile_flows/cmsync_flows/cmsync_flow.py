import copy
import random
import string
import time
from datetime import datetime
from functools import partial

from retrying import retry

from enmutils.lib import filesystem, log, persistence, arguments, timestamp
from enmutils.lib.arguments import get_random_string
from enmutils.lib.enm_node_management import CmManagement
from enmutils.lib.exceptions import (EnvironError, FailedNetsimOperation, NetsimError, MOPathMisMatch,
                                     EnmApplicationError)
from enmutils.lib.persistence import picklable_boundmethod
from enmutils_int.lib import netsim_mo, node_pool_mgr, load_mgr
from enmutils_int.lib.cmsync_mo_info import CmSyncMoInfo, MSCM_MCD_RATE, MSCMCE_MCD_RATE
from enmutils_int.lib.common_utils import chunks
from enmutils_int.lib.ddp_info_logging import update_cm_ddp_info_log_entry
from enmutils_int.lib.enm_user import get_workload_admin_user
from enmutils_int.lib.helper_methods import generate_basic_dictionary_from_list_of_objects
from enmutils_int.lib.netex import Collection
from enmutils_int.lib.netsim_operations import AVCBurst, MCDBurst
from enmutils_int.lib.network_mo_info import NetworkMoInfo, GSM_RELATION_FILE_PATH
from enmutils_int.lib.profile_flows.common_flows.common_flow import GenericFlow
from enmutils_int.lib.services.nodemanager import mutexer
from enmutils_int.lib.services.nodemanager_adaptor import can_service_be_used, allocate_nodes

PROFILE_NOTIFICATION_VALUES = "cmsync-profile-notifications"
PROFILE_NODE_ALLOCATION_VALUES = "cmsync-node-allocations"
ONE_INSTANCE_VERIFICATION = "1 instance(s)"
AVAILABLE_NODES_DICT = {}
GSM_PATHS = {}
CREATED_EXTERNAL_ENODEB_FUNCTION_MOS = {}
ENODEB_VALUES = "eNBId=1000000; eNodeBPlmnId=(mcc=272,mnc=7,mncLength=2)"
MAX_NODES_PER_NOTIFICATION_GROUP = 12


class PersistedNotificationException(EnvironError):
    pass


class CmSyncNodeManager(object):

    def __init__(self, profile, profile_node_requirements=None):
        """
        Init method

        :param profile: Profile object to be used for the allocation process
        :type profile: 'profile.Profile'
        :param profile_node_requirements: Dictionary containing the breakdown of nodes required
        :type profile_node_requirements: dict
        """
        self.profile = profile
        self.profile_requirements = profile_node_requirements

    def allocate_nodes_to_profile(self):
        """
        Allocates nodes to the cmsync profile

        :returns: List of update node instances
        :rtype: list
        """
        node_attributes = ["node_id", "netsim", "simulation", "primary_type", "subnetwork", "node_name",
                           "lte_cell_type"]
        allocated_nodes = self.profile.get_nodes_list_by_attribute(node_attributes=node_attributes)
        if not allocated_nodes:
            total_nodes = sum(self.profile.NUM_NODES.itervalues())
            setattr(self.profile, "TOTAL_NODES", total_nodes)
            log.logger.debug("Setting TOTAL_NODES to {0}.".format(total_nodes))
            if can_service_be_used(self.profile):
                allocate_nodes(self.profile)
            else:
                with node_pool_mgr.mutex():
                    log.logger.debug("Nodes are not currently allocated to the profile, retrieving workload pool "
                                     "before allocating nodes.")
                    pool = node_pool_mgr.get_pool()
                    try:
                        log.logger.debug("Starting allocation of nodes for {0} now.".format(self.profile.NAME))
                        pool.allocate_nodes(self.profile)
                        log.logger.debug("Nodes have been successfully allocated: {0}".format(self.profile.NAME))
                    except Exception as e:
                        log.logger.debug(str(e))
            allocated_nodes = self.profile.get_nodes_list_by_attribute(node_attributes=node_attributes)
        setattr(self.profile, 'num_nodes', len(allocated_nodes))
        self.profile.persist()
        return allocated_nodes


class CmSyncNotificationManager(object):

    def __init__(self, notifications, allocated_nodes_dict, profile_name, num_nodes):
        """
        Init method

        :param notifications: List of notifications to be generated by the profile
        :type notifications: list
        :param allocated_nodes_dict: Dictionary of the currently allocated Nodes
        :type allocated_nodes_dict: dict
        :param profile_name: Name of the profile
        :type profile_name: str
        :param num_nodes: Dictionary containing the required nodes values
        :type num_nodes: dict
        """
        self.notifications = notifications
        self.allocated_nodes_dict = allocated_nodes_dict
        self.profile_name = profile_name
        self.num_nodes = num_nodes

    def alter_notifications_if_under_allocation_of_nodes(self):
        """
        Updates the notification rate and nodes, if the allocated node count is below the required count

        :return: Modified List of notifications to be generated by the profile
        :rtype: list
        """
        if self.profile_name in ["CMSYNC_0{0}".format(_) for _ in range(1, 6, 2)]:
            return self.remove_invalid_notifications()
        altered_notifications = []
        for ne_type, nodes in self.allocated_nodes_dict.iteritems():
            ne_notifications = []
            for notification in self.notifications:
                if notification[0] == ne_type:
                    ne_notifications.append(notification)
            log.logger.debug("\nExisting notifications: {0} for {1}.".format(ne_notifications, ne_type))
            required = self.num_nodes.get(ne_type)
            log.logger.debug("\nDetermining if rate increase is required: [{0}].Allocated nodes: [{1}] required: [{2}]"
                             .format(bool(len(nodes) < required), len(nodes), required))
            rate_increase = required - len(nodes) if nodes and required > len(nodes) else 0
            altered_notifications.extend(self.update_notifications(rate_increase, ne_notifications, len(nodes)))
        log.logger.debug("\nAltered notifications: {0}".format(altered_notifications))
        return altered_notifications

    def remove_invalid_notifications(self):
        """
        Verify the MCD notifications have integer node values and a rate of 0.02

        :return: List of updated notifications
        :rtype: list
        """
        updated_notifications = []
        mscm_rate, mscmce_rate = MSCM_MCD_RATE, MSCMCE_MCD_RATE
        for notification in self.notifications:
            ne_type, mo, num_nodes, rate = notification
            expected_rate = mscm_rate if ne_type == "ERBS" else mscmce_rate
            if rate != expected_rate or num_nodes < 1:
                updated_notifications.append([ne_type, mo, 1, expected_rate])
            else:
                updated_notifications.append(notification)
        return updated_notifications

    def update_notifications(self, rate_increase, ne_notifications, total_count_ne_allocated):
        """
        Updates the notification rate and nodes, for each individual NE Type

        :param rate_increase: Notification rate by which the existing rate is to be increased
        :type rate_increase: int
        :param ne_notifications: List of notifications to be generated by the profile by NE Type
        :type ne_notifications: list
        :param total_count_ne_allocated: The total count of the NE type which needs to reduce its number of nodes
        :type total_count_ne_allocated: int

        :return:  List of notifications to be generated by the profile
        :rtype: list
        """
        if not rate_increase:
            log.logger.debug("\nNo change required, nothing to do.")
            return ne_notifications
        updated_notifications = self.reduce_nodes_required_by_notification(total_count_ne_allocated, ne_notifications)
        return updated_notifications

    def reduce_nodes_required_by_notification(self, total_count_ne_allocated, notifications):
        """
        Updated node count and rate for notifications list for specific ne type

        :param total_count_ne_allocated: The total count of the NE type which needs to reduce its number of nodes
        :type total_count_ne_allocated: int
        :param notifications: List of notifications to be generated by the profile
        :type notifications: list

        :return: Modified List of notifications to be generated by the profile
        :rtype: list
        """
        log.logger.debug("Updating required node count for {0} and increasing rate.".format(self.profile_name))
        updated_notifications = []
        if len(notifications) >= total_count_ne_allocated:
            for notification in notifications:
                ne_type, mo, num_nodes, rate = notification
                diff = abs(num_nodes - total_count_ne_allocated)
                if not diff:
                    updated_notifications.append(notification)
                elif rate < 1.0:
                    updated_notifications.append([ne_type, mo, total_count_ne_allocated, diff * rate])
                else:
                    updated_notifications.append([ne_type, mo, rate, num_nodes])
        else:
            updated_notifications = self.update_notifications_iteratively(total_count_ne_allocated, notifications)
        log.logger.debug("\nNotifications after update: {0}".format(updated_notifications))
        return updated_notifications

    @staticmethod
    def update_notifications_iteratively(total_count_ne_allocated, notifications):
        """
        Updated node count and rate for notifications list for specific ne type iteratively

        :param total_count_ne_allocated: The total count of the NE type which needs to reduce its number of nodes
        :type total_count_ne_allocated: int
        :param notifications: List of notifications to be generated by the profile
        :type notifications: list

        :return: Modified List of notifications to be generated by the profile
        :rtype: list
        """
        updated_notifications = []
        total_required = sum([_[2] for _ in notifications])
        if total_required > total_count_ne_allocated:
            while total_required > total_count_ne_allocated:
                for notification in notifications:
                    ne_type, mo, num_nodes, rate = notification
                    if num_nodes > 1:
                        notifications.append([ne_type, mo, num_nodes - 1, rate + 1])
                        notifications.remove(notification)
                        total_required -= 1
            updated_notifications = notifications
        return updated_notifications

    def expected_notification_summary(self, duration, sleep, notifications):
        """
        Output the expected notification rate per iteration, per day, per profile

        :param duration: Duration of each burst to be generated
        :type duration: int
        :param sleep: Duration of each sleep period
        :type sleep: int
        :param notifications: List of notifications to be generated by the profile
        :type notifications: list
        """
        # number per iteration = total time per day / sleep, for example:  86400 / 7200 = 12
        number_of_iterations_per_day = 86400 / sleep
        profile_total = 0
        for notification in notifications:
            _, _, num_nodes, rate = notification
            expected_notifications_per_iteration = num_nodes * rate * duration
            daily_total = expected_notifications_per_iteration * number_of_iterations_per_day
            profile_total += daily_total
        ts = timestamp.get_human_readable_timestamp()
        update_cm_ddp_info_log_entry(self.profile_name, "{0} {1} {2}\n".format(ts, self.profile_name, profile_total))
        log.logger.debug("\nExpected daily notification generation for profile: {0} is {1}"
                         .format(self.profile_name, profile_total))


class CmSyncFlow(GenericFlow):

    TDD_CELL = "TDD"
    FDD_CELL = "FDD"
    TEARDOWN_OBJECTS = []
    BURSTS = []
    START_SLEEP_TIME = 0

    @property
    def burst_id(self):
        return datetime.now().strftime("%m%d%H%M%S%f")

    def get_and_set_num_nodes_from_persistence(self):
        """
        Get the persisted profile num node dictionary

        :raises PersistedNotificationException: raised if notifications are not available in redis for profile

        :returns: List of updated node instances
        :rtype: list
        """
        if persistence.get(PROFILE_NODE_ALLOCATION_VALUES) and self.NAME in persistence.get(
                PROFILE_NODE_ALLOCATION_VALUES):
            num_nodes = persistence.get(PROFILE_NODE_ALLOCATION_VALUES).get(self.NAME)
            log.logger.debug("Value for NUM NODES found, setting value: {0}".format(num_nodes))
            setattr(self, "NUM_NODES", num_nodes)
            self.persist()
            node_mgr = CmSyncNodeManager(self)
            return node_mgr.allocate_nodes_to_profile()
        else:
            raise PersistedNotificationException("Unable to retrieve to persisted num nodes information for {0}."
                                                 "Please ensure CMSYNC_SETUP is active, and restart one or both "
                                                 "profiles.".format(self.NAME))

    def get_and_manage_notifications(self):
        """
        Get notification information and alters if below required amount

        :raises EnvironError:  Raised if notification information is not available from persistence
        :return: List of notifications for the profile to use
        :rtype: List
        """
        log.logger.debug("Getting notification information for the profile")
        notifications = self.get_notification_information_for_profile()
        if not notifications:
            raise EnvironError("Unable to determine notification(s) for {0}, please ensure CMSYNC_SETUP is "
                               "running, and not in ERROR state, sleeping until next iteration."
                               .format(self.NAME))
        notification_mgr = CmSyncNotificationManager(notifications, AVAILABLE_NODES_DICT, self.NAME,
                                                     self.NUM_NODES)
        notification_mgr.expected_notification_summary(self.BURST_DURATION, self.SCHEDULE_SLEEP, notifications)
        notifications = notification_mgr.alter_notifications_if_under_allocation_of_nodes()
        return notifications

    @staticmethod
    def distribute_large_notification_groups(notifications):
        """
        Convert large notification groups into smaller groups so that
        they will be better distributed among different threads.

        :param notifications: List of notifications before split
        :type notifications: list
        :return: List of notifications after splitting large groups
        :rtype: list
        """
        distributed_notifications = []
        for notification_group in notifications:
            if notification_group[2] > MAX_NODES_PER_NOTIFICATION_GROUP:
                for _ in range(0, notification_group[2], MAX_NODES_PER_NOTIFICATION_GROUP):
                    distributed_notifications.append(notification_group[:2] + [
                        MAX_NODES_PER_NOTIFICATION_GROUP] + notification_group[-1:])
                if notification_group[2] % MAX_NODES_PER_NOTIFICATION_GROUP != 0:
                    distributed_notifications[-1] = notification_group[:2] + [
                        notification_group[2] % MAX_NODES_PER_NOTIFICATION_GROUP] + notification_group[-1:]
            else:
                distributed_notifications.append(notification_group)
        log.logger.debug("Notification groups after distributing groups larger than"
                         " {0} - {1}.".format(MAX_NODES_PER_NOTIFICATION_GROUP, distributed_notifications))
        return distributed_notifications

    def execute_threads_for_notifications(self, notifications):
        """
        Sends AVC Bursts on the notications
        :param notifications: List of lists containing our notifications
        :type notifications: List
        :raises KeyboardInterrupt: When the process is interupted
        """
        log.logger.debug("Attempting to send AVC Bursts on the notifications")
        try:
            self.BURSTS = []
            self.create_and_execute_threads(workers=notifications, thread_count=24, args=[self],
                                            wait=self.SCHEDULE_SLEEP - 230, join=10)
            chunk_size = len(self.BURSTS) / 12 if len(self.BURSTS) / 12 else 1
            burst_chunks = [chunk for chunk in chunks(self.BURSTS, chunk_size)]
            log.logger.debug("Total number of burst chunks: [{0}]".format(len(burst_chunks)))
            self.create_and_execute_threads(workers=burst_chunks, func_ref=self.start_all_bursts,
                                            thread_count=len(burst_chunks), args=[self])
        except KeyboardInterrupt:
            elapsed = int(time.time() - self.START_SLEEP_TIME)
            if getattr(self, 'BURST_DURATION', None) and elapsed >= getattr(self, 'BURST_DURATION'):
                self.teardown_list.extend(self.TEARDOWN_OBJECTS)
            raise

    def execute_flow(self):
        """
        Executes the flow for the profile
        """
        self.state = "RUNNING"
        load_mgr.wait_for_setup_profile("CMSYNC_SETUP", state_to_wait_for="SLEEPING")
        if getattr(self, 'SCHEDULED_TIMES_STRINGS', None):
            self.sleep_until_next_scheduled_iteration()
        while self.keep_running():
            try:
                global AVAILABLE_NODES_DICT, GSM_PATHS
                AVAILABLE_NODES_DICT = generate_basic_dictionary_from_list_of_objects(
                    self.get_and_set_num_nodes_from_persistence(), "primary_type")
                if self.NUM_NODES.get("RNC"):
                    self.read_gsm_relations_from_file_and_sort()
                notifications = self.get_and_manage_notifications()
                notifications = self.distribute_large_notification_groups(notifications)
                self.execute_threads_for_notifications(notifications)
                AVAILABLE_NODES_DICT, GSM_PATHS = [{}] * 2
                self._sleep_exchange_nodes_and_remove_bursts()
            except Exception as e:
                self.add_error_as_exception(e)
                self.sleep_until_next_scheduled_iteration()

    def get_notification_information_for_profile(self):
        """
        Get the persisted profile notification dictionary

        :raises PersistedNotificationException: raised if notifications are not available in redis for profile

        :return: List of notifications to be generated by the profile
        :rtype: list
        """
        log.logger.debug("Retrieving notification information for {0}".format(self.NAME))
        if persistence.get(PROFILE_NOTIFICATION_VALUES) and self.NAME in persistence.get(PROFILE_NOTIFICATION_VALUES):
            notification_list = persistence.get(PROFILE_NOTIFICATION_VALUES).get(self.NAME)
            log.logger.debug("Notifications found for {0} : {1}".format(self.NAME, notification_list))
            return notification_list
        else:
            raise PersistedNotificationException("Unable to retrieve to persisted notification information for {0}."
                                                 "Please ensure {1} is correctly or start CMSYNC_SETUP."
                                                 .format(self.NAME, PROFILE_NOTIFICATION_VALUES))

    @staticmethod
    def task_set(worker, profile):
        """
        Retrieves and invokes the functionality to create, and start the burst notifications

        :param worker: Object to be the worker
        :type worker: list
        :param profile: Profile object to execute the functionality
        :type profile: `flow_profile.FlowProfile`
        """
        mo_types = []
        ne_type, mo_name, num_nodes, notification_rate = worker
        nodes = profile.get_nodes(ne_type, num_nodes)
        if nodes:
            mo_name = profile.update_radio_nodes_mo_name(ne_type, mo_name)
            log.logger.debug("Notification values, NeType [{0}], Mo [{1}],  Number of nodes [{2}] Rate per second"
                             " [{3}]".format(ne_type, mo_name, len(nodes), notification_rate))
            mo_types.extend(profile.get_mo_types(ne_type, mo_name, nodes, notification_rate))
            profile.BURSTS.extend(profile.create_bursts(mo_types, notification_rate))
        else:
            log.logger.debug("No available nodes, to generate Notification: NeType [{0}], Mo [{1}], Number of nodes "
                             "[{2}] Rate per second [{3}]. nothing to do.".format(ne_type, mo_name, num_nodes,
                                                                                  notification_rate))

    @staticmethod
    def start_all_bursts(bursts, profile):
        """
        Function passed to the threads to execute the list of bursts

        :param bursts: List of bursts to be started
        :type bursts: list
        :param profile: Profile flow which will start the bursts
        :type profile: `CmSyncFlow`
        """
        profile.start_bursts(bursts)

    def update_radio_nodes_mo_name(self, ne_type, mo_name):
        """
        Update the mo for certain RadioNode MO names.

        :param ne_type: Node type to be used
        :type ne_type: str
        :param mo_name: Name of the Mo to be used
        :type mo_name: str

        :return: Returns the updated mo name
        :rtype: str
        """
        log.logger.debug("Updating the RadioNode MO values, to prefix Lrat: if required.")
        if ne_type == "RadioNode" and (self.BURST_TYPE == "MCD" or mo_name in ["PmEventService", "TermPointToENB"]):
            mo_name = "Lrat:{0}".format(mo_name)
        return mo_name

    def get_nodes(self, ne_type, num_nodes):
        """
        Gets the available nodes for the burst

        :param ne_type: Node type to be used
        :type ne_type: str
        :param num_nodes: Number of nodes to be used in the burst
        :type num_nodes: int

        :return: List of node objects to be used, to create the notifications
        :rtype: list
        """
        with mutexer.mutex('cmsync-flow-nodes-key'):
            nodes = []
            available = AVAILABLE_NODES_DICT.get(ne_type) if AVAILABLE_NODES_DICT.get(ne_type) else []
            log.logger.debug("Attempting to assign {0} {1} nodes to be used by the burst instance, available: {2}."
                             .format(num_nodes, ne_type, len(available)))
            try:
                if num_nodes >= len(available):
                    nodes.extend(available)
                    if getattr(self, 'NAME') == "CMSYNC_01":
                        self.remove_unavailable_nodes(ne_type, nodes, empty_list=True)
                else:
                    nodes = random.sample(available, num_nodes)
                    self.remove_unavailable_nodes(ne_type, nodes)
            except Exception as e:
                log.logger.debug("Encountered an error while attempting to allocate nodes to burst, exception [{}]."
                                 .format(str(e)))
            return nodes

    @staticmethod
    def read_gsm_relations_from_file_and_sort():
        """
        Reads in the list of UtranCells, and sorts by node
        """
        utrancells_from_file = filesystem.get_lines_from_file(GSM_RELATION_FILE_PATH)
        sorted_cells = {}

        global GSM_PATHS
        for _ in utrancells_from_file:
            key = _.split('UtranCell=')[-1].split('-')[0]
            if key not in sorted_cells.keys():
                sorted_cells[key] = []
            sorted_cells[key].append(_)
        GSM_PATHS = sorted_cells

    def get_mo_types(self, ne_type, mo, nodes, notification_rate):
        """
        Create the MOType object for each required notification

        :param ne_type: Node type to be used
        :type ne_type: str
        :param mo: Name of the Mo to be used
        :type mo: str
        :param nodes: List of `load_node.Node` objects
        :type nodes: list
        :param notification_rate: rate at which notifications should be issued
        :type notification_rate: int

        :return: List of MoType objects
        :rtype: `MOType`
        """
        mo_type = []
        log.logger.debug("Starting creation of MO Type instances.")
        for notification_info in self.NOTIFICATION_INFO.get(ne_type):
            if notification_info.get('mo_type_name') == mo:
                tdd_nodes = [node for node in nodes if node.lte_cell_type == self.TDD_CELL or
                             self.TDD_CELL in node.simulation]
                fdd_nodes = list(set(nodes).difference(tdd_nodes))
                if not tdd_nodes:
                    mo_type.extend(self.get_mo_type_instances(ne_type, mo, nodes, notification_rate,
                                                              notification_info))
                else:
                    if fdd_nodes:
                        mo_type.extend(self.get_mo_type_instances(ne_type, mo, fdd_nodes, notification_rate,
                                                                  notification_info))
                    notification_copy = copy.deepcopy(notification_info)
                    tdd_mo, tdd_notification_info = self.update_notification_values_for_tdd_cell_nodes(
                        mo, notification_copy)
                    mo_type.extend(self.get_mo_type_instances(ne_type, tdd_mo, tdd_nodes, notification_rate,
                                                              tdd_notification_info))
        log.logger.debug("Completed creation of MO Type instances.")
        return mo_type

    def update_notification_values_for_tdd_cell_nodes(self, mo, notification_info):
        """
        Update the supplied MO name and notification info if not TDD compatible

        :param mo: Name of the MO
        :type mo: str
        :param notification_info: Dictionary containing MO information
        :type notification_info: dict

        :return: Updated MO name and notification info for TDD Burst
        :rtype: tuple
        """
        tdd_mo = mo.replace(self.FDD_CELL, self.TDD_CELL)
        log.logger.debug("Replacing FDD information, TDD cells detected.")
        for key, value in notification_info.items():
            if not value or key not in ["parent_mo_names", "mo_type_name", "mo_path"]:
                continue
            elif hasattr(value, 'append'):
                notification_info[key] = [val.replace("FDD", "TDD") for val in value]
            else:
                notification_info[key] = value.replace(self.FDD_CELL, self.TDD_CELL)
        return tdd_mo, notification_info

    def get_mo_type_instances(self, ne_type, mo, nodes, notification_rate, notification_info):
        """
        Create the MOType object for each required notification

        :param ne_type: Node type to be used
        :type ne_type: str
        :param mo: Name of the Mo to be used
        :type mo: str
        :param nodes: List of `load_node.Node` objects
        :type nodes: list
        :param notification_rate: rate at which notifications should be issued
        :type notification_rate: int
        :param notification_info: Dictionary containing the notification information
        :type notification_info: dict

        :return: List of MoType objects
        :rtype: list
        """
        mo_type = []
        if ne_type == "RNC" and GSM_PATHS:
            for node in nodes:
                try:
                    mo_type.extend(self.get_rnc_mo_type(ne_type, mo, node, notification_rate, notification_info))
                except MOPathMisMatch as e:
                    self.add_error_as_exception(e)
        elif ne_type == 'RadioNode':
            lte_notification_info = notification_info
            for node in nodes:
                notification_info = lte_notification_info
                if 'gNodeB' in node.node_id:
                    notification_info = self.get_notification_info_for_5g_nodes(mo, ne_type)

                mo_type.extend(self.build_mo_type_instances(ne_type, notification_info, [node], notification_rate))

        else:
            mo_type = self.build_mo_type_instances(ne_type, notification_info, nodes, notification_rate)
        return mo_type

    def get_notification_info_for_5g_nodes(self, mo, ne_type):
        """
        Retrieves the notification information for 5g nodes

        :param mo: Name of the Mo to be used
        :type mo: str
        :param ne_type: Node type to be used
        :type ne_type: str

        :return: Dictionary containing the 5g notification information
        :rtype: dict
        """

        mo_replacements = {'EUtranCellFDD': 'GNBDU:NRCellDU', 'Lrat:TermPointToENB': 'GNBCUCP:NRCellRelation',
                           'EUtranCellRelation': 'GNBCUCP:EUtranCellRelation',
                           'EUtranFreqRelation': 'GNBCUCP:EUtranFreqRelation',
                           'ExternalEUtranCellFDD': 'GNBCUCP:GNBCUCPFunction',
                           'Lrat:PmEventService': 'GNBCUCP:NRCellCU', 'UtranCellRelation': 'GNBDU:NRSectorCarrier'}
        mo_replacements_for_create_and_delete = ['GNBCUUP:EP_NgU', 'GNBCUUP:EP_XnU', 'GNBCUUP:S1ULink',
                                                 'GNBCUUP:X2ULink']

        five_g_mo = random.choice(mo_replacements_for_create_and_delete) if self.NAME == 'CMSYNC_01' else mo_replacements[mo]
        log.logger.debug('Replacing Radio Node MO for 5G Radio Node MO: {0}'.format(five_g_mo))
        for notification_info in self.NOTIFICATION_INFO.get(ne_type):
            if notification_info.get('mo_type_name') == five_g_mo:
                return notification_info

    def get_rnc_mo_type(self, ne_type, mo, node, notification_rate, notification_info):
        """
        Create the MOType object for RNC nodes

        :param ne_type: Node type to be used
        :type ne_type: str
        :param mo: Name of the Mo to be used
        :type mo: str
        :param node: ENM node instance
        :type node: `enm_node.Node`
        :param notification_rate: rate at which notifications should be issued
        :type notification_rate: int
        :param notification_info: Dictionary containing notification information, path, ne, and so on
        :type notification_info: dict

        :return: List of MoType objects
        :rtype: `MOType`
        """
        log.logger.debug("Updating RNC burst info to use predefined cells if available.")
        mo_burst_info = self.set_rnc_path(node.node_id, mo, notification_info)
        return self.build_mo_type_instances(ne_type, mo_burst_info, [node], notification_rate)

    def build_mo_type_instances(self, ne_type, mo_burst_info, nodes, notification_rate):
        """
        Creates MOType instance(s) for each required notification

        :param ne_type: Node type to be used
        :type ne_type: str
        :param mo_burst_info: Notification values contained in a dictionary
        :type mo_burst_info: dict
        :param nodes: List of `load_node.Node` objects
        :type nodes: list
        :param notification_rate: rate at which notifications should be issued
        :type notification_rate: int

        :return: List of MoType objects
        :rtype: `MOType`
        """
        log.logger.debug("BURST INFO: {node_type} - {mo_name}: Number of nodes assigned: {num_nodes}, "
                         "MO Burst info: {mo_info}".format(node_type=ne_type,
                                                           mo_name=mo_burst_info['mo_type_name'],
                                                           num_nodes=len(nodes),
                                                           mo_info=mo_burst_info))
        mo_type = netsim_mo.determine_mo_types_required(mo_burst_info, nodes,
                                                        for_existing_mo=bool(self.BURST_TYPE == "AVC"))
        if self.BURST_TYPE == "AVC":
            for m_type in mo_type[:]:
                m_type.add_avc_burst_info(notification_rate=notification_rate,
                                          mo_attribute=mo_burst_info["mo_attribute"],
                                          mo_values=mo_burst_info["mo_values"])
        return mo_type

    @retry(retry_on_exception=lambda e: isinstance(e, MOPathMisMatch), wait_fixed=1000, stop_max_attempt_number=3)
    def set_rnc_path(self, node_id, mo, mo_burst_info):
        """
        Set the RNC path to limit dumpmotree

        :param node_id: Node id used as a key, to retrieve a path value
        :type node_id: str
        :param mo: Name of the MO to be used in the burst
        :type mo: str
        :param mo_burst_info: Dictionary containing notification information, path, ne, and so on
        :type mo_burst_info: dict

        :return: Updated mo_burst_info dictionary
        :rtype: dict
        """
        log.logger.debug("Setting the rnc path for node id {0}".format(node_id))
        if getattr(self, "BURST_TYPE", "AVC") == "AVC":
            mo_burst_info = self.get_rnc_path_avc_burst(node_id, mo_burst_info, mo)
        return mo_burst_info

    def get_rnc_path_avc_burst(self, node_id, mo_burst_info, mo):
        """
        Set the RNC AVCBurst path to limit dumpmotree usage

        :param node_id: Node id used as a key, to retrieve a path value
        :type node_id: str
        :param mo: Name of the MO to be used in the burst
        :type mo: str
        :param mo_burst_info: Dictionary containing notification information, path, ne, and so on
        :type mo_burst_info: dict

        :raises MOPathMisMatch: raised if the RNC node id cannot be matched to a GSM Relation

        :return: Updated mo_burst_info dictionary
        :rtype: dict
        """
        global GSM_PATHS
        matched_gsm_relation = None
        mo_burst_info_to_update = copy.deepcopy(mo_burst_info)
        with mutexer.mutex('gsm-path-mutex'):
            gsm_relation_fdns = GSM_PATHS.get(node_id)
            if node_id in GSM_PATHS.keys() and gsm_relation_fdns:
                for gsm_relation in random.sample(gsm_relation_fdns, len(gsm_relation_fdns)):
                    if node_id == gsm_relation.split('UtranCell=')[-1].split('-')[0]:
                        matched_gsm_relation = gsm_relation
                        gsm_relation_fdns.remove(gsm_relation)
                        GSM_PATHS[node_id] = gsm_relation_fdns
                        break
                if not matched_gsm_relation:
                    raise MOPathMisMatch("Unable to determine matching RNC GSM Relation for RNC: [{0}].".format(
                        node_id))
                mo_burst_info_to_update = self.update_rnc_mo_info(mo, mo_burst_info_to_update, matched_gsm_relation)
            self.validate_rnc_mo_path(node_id, mo_burst_info_to_update["mo_path"])
            log.logger.debug("Using RNC path {0} for node {1} and mo {2}".format(mo_burst_info_to_update["mo_path"],
                                                                                 node_id, mo))
            return mo_burst_info_to_update

    @staticmethod
    def update_rnc_mo_info(mo, mo_burst_info, gsm_relation):
        """
        Split the GSM Relation based upon the supplied MO

         :param mo: Name of the MO to be used in the burst
        :type mo: str
        :param mo_burst_info: Dictionary containing notification information, path, ne, and so on
        :type mo_burst_info: dict
        :param gsm_relation: Supplied GSM Relation
        :type gsm_relation: str

        :return: Updated dictionary containing notification information, path, ne, and so on
        :rtype: dict
        """
        if mo not in ["GsmRelation", "UtranCell"]:
            # NSS-25023 IDs for Rach/Pch/Fach/Hscdsch should always be == 1
            mo_burst_info["mo_path"] = "{0},{1}={2}".format(gsm_relation.split(",GsmRelation")[0], mo, 1)
        elif mo == "UtranCell":
            mo_burst_info["mo_path"] = gsm_relation.split(",GsmRelation")[0]
        else:
            mo_burst_info["mo_path"] = gsm_relation
        mo_burst_info["parent_mo_names"] = None
        return mo_burst_info

    @staticmethod
    def validate_rnc_mo_path(node_id, mo_path):
        """
        Validate the mo path belongs to the supplied node

        :param node_id: Id of the node object
        :type node_id: str
        :param mo_path: Path to the MO to be validated
        :type mo_path: str
        :raises MOPathMisMatch: raised if the existing MO path does not match the RNC node id
        """
        if mo_path and mo_path.split("UtranCell=")[-1].split('-')[0] != node_id:
            raise MOPathMisMatch("MO path node {0} does not match the supplied node {1}. "
                                 "Ensure that GsmRelations are present on the node."
                                 .format(mo_path.split("UtranCell=")[-1].split('-')[0], node_id))

    @staticmethod
    def random_mo_values(mo_value):
        """
        To create a list of random mo_values

        :param mo_value: List of mo_values of given mo
        :type mo_value: List
        :return: The list of modified MO values
        :rtype: list
        """
        new_mo_values = []
        for _ in mo_value:
            old_string = (_.split('_'))[1]
            new_string = get_random_string(size=8, exclude='ok' + string.ascii_uppercase + string.digits)
            new_mo_values.append(_.replace(old_string, new_string))
        return new_mo_values

    def create_bursts(self, mo_types, notification_rate):
        """
        Create the burst object based upon the supplied MOType objects

        :param mo_types: List of MoType objects
        :type mo_types: list [`netsim_mo.MOType`]
        :param notification_rate: Rate at which the notifications should be generated
        :type notification_rate: int

        :return: List of Burst objects
        :rtype: `netsim_operations.Burst`
        """
        bursts = []
        for mo_type in mo_types:
            # Create the burst and sleep so the burst_id are not created with the same timestamp
            time.sleep(float(random.randrange(1, 1000)) / 1000)
            log.logger.debug("Creating Burst instance, of type {0}.".format(self.BURST_TYPE))
            if self.BURST_TYPE == "MCD":
                burst = MCDBurst(nodes=mo_type.nodes, burst_id=self.burst_id, duration=self.BURST_DURATION,
                                 burst_rate=notification_rate,
                                 new_mos_info=self.get_new_mo_info_for_mcd_burst(mo_type),
                                 mcd_data_attrs=self.get_mandatory_mcd_data_attributes(
                                     mo_type.mos[-1], mo_type.nodes[0].node_id,
                                     cell_type=mo_type.nodes[0].lte_cell_type))
            else:
                if mo_type.mo_attribute == "userLabel" and self.NAME == "CMSYNC_02":
                    modified_mo_values = self.random_mo_values(mo_type.mo_values)
                else:
                    modified_mo_values = mo_type.mo_values
                burst = AVCBurst(nodes=mo_type.nodes, burst_id=self.burst_id, duration=self.BURST_DURATION,
                                 burst_rate=notification_rate, mo_path=mo_type.mo_path,
                                 mo_attribute=mo_type.mo_attribute, mo_values=modified_mo_values,
                                 notification_rate=notification_rate)

            bursts.append(burst)
        return bursts

    def get_new_mo_info_for_mcd_burst(self, mo_type):
        """
        Retrieve the New MO information to be used for the create operation

        :param mo_type: MoType instance
        :type mo_type: `netsim_mo.MOType`

        :return: List containing a dictionary, containing the parent MO path and the New MO info
        :rtype: list
        """

        new_mo_name = "{0}-{1}".format(self.NAME.replace("_", ""), self.burst_id)
        mo = mo_type.mos[-1]
        log.logger.debug("Retrieving New MO info, for MO {0}.".format(mo))
        new_mos_info = [{'mo_parent_path': mo_type.parent_mo_path, 'New_MO_Info': [(mo, new_mo_name)]}]
        if mo in ["TermPointToENB", "ExternalEUtranCellFDD", "ExternalEUtranCellTDD"]:
            self.create_external_enodeb_function(nodes=mo_type.nodes)
            sleep_time = 30
            log.logger.debug("Sleeping for {0} to allow parent MOs to be created.".format(sleep_time))
            time.sleep(sleep_time)
            parent_mo_path = self.get_matching_parent_mo(mo_type.nodes) or mo_type.parent_mo_path
            new_mos_info = [{'mo_parent_path': parent_mo_path, 'New_MO_Info': [(mo, new_mo_name)]}]
        log.logger.debug("New MO info:: {0}.".format(new_mos_info))
        return new_mos_info

    @staticmethod
    def get_matching_parent_mo(nodes):
        """
        Check for matching ExternalENodeBFunctions created for use with MCDBursts on supplied node(s)

        :param nodes: List of node ids
        :type nodes: list

        :return: Matched Parent MO path or None
        :rtype: matched MO path or None
        """

        matched = []
        for node in nodes:
            log.logger.debug("Checking for matching ExternalENodeBFunctions for node:: {0}".format(node.node_id))
            created_mos = CREATED_EXTERNAL_ENODEB_FUNCTION_MOS.get(node.node_id)
            if not created_mos or not all(created_mos):
                return None
            matched.append(CREATED_EXTERNAL_ENODEB_FUNCTION_MOS.get(node.node_id))
        common_mos = list(set.intersection(*[set(_) for _ in matched]))
        log.logger.debug("Matched result for all node(s):: {0}".format(common_mos))
        return common_mos[0] if common_mos else None

    def start_bursts(self, bursts):
        """
        Invokes the start function on the created burst instances

        :param bursts: List of MCD or AVC burst objects
        :type bursts: list
        """
        for burst in bursts:
            num_failed_nodes = 0
            try:
                log.logger.debug("Attempting to start burst command on NetSim.")
                burst.start()
                log.logger.debug("Burst command, started successfully.")
                self.TEARDOWN_OBJECTS.append(picklable_boundmethod(burst.stop))
            except FailedNetsimOperation as e:
                num_failed_nodes += len(e.nodes)
                log.logger.debug("FailedNetsimOperation exception raised. Reason: {0}".format(str(e)))
                if not all([num_failed_nodes, len(burst.nodes)]):
                    self.add_error_as_exception(
                        NetsimError("Start {0} Burst failed on nodes. Check logs at {1}"
                                    .format(self.BURST_TYPE, self.LOG_PATH.format(self.NAME.lower()))))
                else:
                    log.logger.debug("Num Failed nodes: {0}".format(num_failed_nodes))
                    self.add_error_as_exception(
                        NetsimError("Start {3} Burst failed on {0}/{1} nodes. Check logs at {2}"
                                    .format(num_failed_nodes, len(burst.nodes), self.LOG_PATH.format(self.NAME.lower()),
                                            self.BURST_TYPE)))
            except Exception as e:
                self.add_error_as_exception(NetsimError("Start {2} Burst failed for some or all of the following "
                                                        "nodes: {0} ERROR:{1}".format(burst.nodes, e, self.BURST_TYPE)))

    @staticmethod
    def remove_unavailable_nodes(ne_type, allocated_nodes, empty_list=False):
        """
        Update available updates to remove the unavailable nodes

        :param ne_type: Type of node allocated
        :type ne_type: str
        :param allocated_nodes: List of unavailable `load_node.LoadNode` objects
        :type allocated_nodes: list
        :param empty_list: Boolean indicating if the list of nodes should be emptied for MCDBursts
        :type empty_list: bool
        """
        global AVAILABLE_NODES_DICT
        if len(allocated_nodes) >= len(AVAILABLE_NODES_DICT.get(ne_type)) and not empty_list:
            log.logger.debug("Removing nodes will empty available pool, nothing to do.")
            return
        log.logger.debug("Removing in-use nodes, to prevent execution of multiple notifications.")
        for node in allocated_nodes:
            try:
                AVAILABLE_NODES_DICT.get(ne_type).remove(node)
            except ValueError:
                continue

    def _sleep_exchange_nodes_and_remove_bursts(self):
        """
        Calls the sleep operation, exchanges nodes and removes completed bursts from teardown
        """
        self.START_SLEEP_TIME = time.time()
        self.sleep_until_next_scheduled_iteration()
        del self.teardown_list[:]
        self.TEARDOWN_OBJECTS = []
        global CREATED_EXTERNAL_ENODEB_FUNCTION_MOS
        if CREATED_EXTERNAL_ENODEB_FUNCTION_MOS:
            user = get_workload_admin_user()
            self.delete_created_external_enodeb_function_mos(user, self.get_nodes_list_by_attribute())
            CREATED_EXTERNAL_ENODEB_FUNCTION_MOS = {}
        self.exchange_nodes()
        log.logger.debug("Successfully exchanged nodes and removed all bursts from teardown list.")

    def get_mandatory_mcd_data_attributes(self, mo_name, node_id, cell_type=None):
        """
        Retrieves the mandatory MO attributes to be used in the MCDBurst

        :param mo_name: Name of the MO to retrieve the mandatory attribute values
        :type mo_name: str
        :param node_id: Node id to retrieve the reference MO
        :type node_id: str
        :param cell_type: Node attribute identifying LTE nodes as FDD or TDD
        :type cell_type: str

        ExternalEUtranCellFDD:
                            - tac   {0..65535}  int32
                            - physicalLayerSubCellId    {0..2}  int32
                            - localCellId   {0..255}    int32
                            - physicalLayerCellIdGroup  {0..167} int32
                            - ExternalEUtranCellFDDId   string
                            - eutranFrequencyRef    MORef

        ExternalUtranCellFDD:
                            - plmnIdentity Will default to {mcc=0, mnc=0, mncLength=2}
                            - cellIdentity  Will default to {rncId=1, cId=0}
                            - physicalCellIdentity  {0..511} int32
                            - ExternalUtranCellFDDId   string

        EUtranCellRelation:
                            - EUtranCellRelationId  string
                            - neighborCellRef   MORef

        UtranCellRelation:
                            - UtranCellRelationId   string
                            - externalUtranCellFDDRef   MORef

        ExternalENodeBFunction:
                            - eNBId {0..1048575}    int32
                            - eNodeBPlmnId  Will default to {mcc=0, mnc=0, mncLength=2}
                            - ExternalENodeBFunctionId  string

        TermPointToENB:
                            - TermPointToENBId  string

        :return: List of mandatory attributes for the supplied MO Name
        :rtype: list
        """
        mo_attr_dict = {
            "ExternalEUtranCellFDD": [
                '{\\"ExternalEUtranCellFDDId=CMSYNC\\"}',
                '{\\"tac=60000\\"}',
                '{\\"physicalLayerSubCellId=1\\"}',
                '{\\"physicalLayerCellIdGroup=100\\"}',
                '{\\"localCellId=200\\"}'
            ],
            "ExternalUtranCellFDD": [
                '{\\"ExternalUtranCellFDDId=CMSYNC\\"}',
                '{\\"physicalCellIdentity=100\\"}'
            ],
            "EUtranCellRelation": [
                '{\\"EUtranCellRelationId=CMSYNC\\"}'
            ],
            "GeranCellRelation": [
                '{\\"geranCellRelationId=CMSYNC\\"}'
            ],
            "UtranCellRelation": [
                '{\\"UtranCellRelationId=CMSYNC\\"}'
            ],
            "ExternalGeranCell": [
                '{\\"ExternalGeranCellId=CMSYNC\\"}',
                '{\\"cellIdentity=1\\"}',
                '{\\"bcc=1\\"}',
                '{\\"ncc=1\\"}',
                '{\\"lac=1\\"}'
            ],
            "Lrat:ExternalEUtranCellFDD": [
                '{\\"externalEUtranCellFDDId=CMSYNC\\"}',
                '{\\"tac=60000\\"}',
                '{\\"physicalLayerSubCellId=1\\"}',
                '{\\"physicalLayerCellIdGroup=100\\"}',
                '{\\"localCellId=200\\"}'
            ],
            "Lrat:ExternalUtranCellFDD": [
                '{\\"externalUtranCellFDDId=CMSYNC\\"}',
                '{\\"physicalCellIdentity=100\\"}'
            ],
            "Lrat:EUtranCellRelation": [
                '{\\"eUtranCellRelationId=CMSYNC\\"}'
            ],
            "Lrat:GeranCellRelation": [
                '{\\"geranCellRelationId=CMSYNC\\"}'
            ],
            "Lrat:UtranCellRelation": [
                '{\\"utranCellRelationId=CMSYNC\\"}'
            ],
            "Lrat:ExternalGeranCell": [
                '{\\"bcc=1\\"}',
                '{\\"ncc=1\\"}',
                '{\\"lac=1\\"}'
            ],
            'GNBCUUP:EP_NgU': [
                '{\\"eP_NgUId=CMSYNC01_' + get_random_string(size=8, exclude='ok' + string.ascii_uppercase + string.digits) + '\\"}'
            ],
            'GNBCUUP:EP_XnU': [
                '{\\"eP_XnUId=CMSYNC01_' + get_random_string(size=8, exclude='ok' + string.ascii_uppercase + string.digits) + '\\"}'
            ],
            'GNBCUUP:S1ULink': [
                '{\\"s1ULinkId=CMSYNC01_' + get_random_string(size=8, exclude='ok' + string.ascii_uppercase + string.digits) + '\\"}'
            ],
            'GNBCUUP:X2ULink': [
                '{\\"x2ULinkId=CMSYNC01_' + get_random_string(size=8, exclude='ok' + string.ascii_uppercase + string.digits) + '\\"}'
            ],
        }
        mo_attrs = (mo_attr_dict.get(mo_name) if mo_attr_dict.get(mo_name) else
                    mo_attr_dict.get(mo_name.replace(self.TDD_CELL, self.FDD_CELL)))
        if mo_name.replace('Lrat:', '') in ["ExternalEUtranCellFDD", "ExternalEUtranCellTDD", "EUtranCellRelation",
                                            "UtranCellRelation"]:
            if not cell_type:
                cell_type = self.TDD_CELL if self.TDD_CELL in mo_name else self.FDD_CELL
            fdn_ref = self.build_fdn_reference_string(node_id, mo_name.replace('Lrat:', ''), cell_type)
            mo_attrs.append(fdn_ref)
            mo_attr_dict[mo_name] = mo_attrs
        if self.TDD_CELL in mo_name or (cell_type and cell_type == self.TDD_CELL):
            log.logger.debug("Altering MCD Burst information for MO [{0}] and Cell Type [{1}].".format(mo_name,
                                                                                                       cell_type))
            mo_attrs = [value.replace(self.FDD_CELL, self.TDD_CELL) for value in mo_attrs]
        else:
            mo_attrs = mo_attr_dict.get(mo_name)
        return mo_attrs

    def build_fdn_reference_string(self, node_id, mo_name, cell_type):
        """
        Create the Referenced MO FDN value

        :param node_id: Node id to retrieve the reference MO
        :type node_id: str
        :param mo_name: MO name which requires the reference attribute
        :type mo_name: str
        :param cell_type: Determine whether the cell is TDD or FDD
        :type cell_type: str
        :return: The constructed MO reference attribute

        :rtype: str
        """
        log.logger.debug('Building FDN reference string for node: [{0}], MO: [{1}]'.format(node_id, mo_name))
        opening_str = '{\\"'
        closing_str = '\\"}'
        required_fdn_reference = self.get_ref_mo_value(node_id, mo_name, cell_type)
        if mo_name in ["ExternalEUtranCellFDD", "ExternalEUtranCellTDD"]:
            mo_ref = "{0}{1}{2}".format(opening_str, 'eutranFrequencyRef={0}'.format(required_fdn_reference),
                                        closing_str)
        elif mo_name == "EUtranCellRelation":
            mo_ref = "{0}{1}{2}".format(opening_str, 'neighborCellRef={0}'.format(required_fdn_reference),
                                        closing_str)
        else:
            mo_ref = "{0}{1}{2}".format(opening_str, 'externalUtranCellFDDRef={0}'.format(required_fdn_reference),
                                        closing_str)
        return mo_ref

    def get_ref_mo_value(self, node_id, mo_name, cell_type):
        """
        Query ENM for the required MO to be used an attribute reference

        :param node_id: Node id to retrieve the reference MO
        :type node_id: str
        :param mo_name: MO name which requires the reference attribute
        :type mo_name: str
        :param cell_type: Determine whether the cell is TDD or FDD
        :type cell_type: str

        :raises EnmApplicationError: raised no suitable reference is found or cmedit command fails

        :return: ManagedElement to MO required of the detected FDN
        :rtype: str
        """
        log.logger.debug(
            'Getting reference MO attribute value for node: [{0}], MO name: [{1}]'.format(node_id, mo_name))
        utrancell_ref = "ExternalUtranCellFDD" if cell_type != self.TDD_CELL else "ExternalUtranCellTDD"
        external_eutrancell_ref = "EUtranFrequency"
        mo_ref_dict = {"UtranCellRelation": utrancell_ref, "EUtranCellRelation": "EUtranCellRelation.neighborCellRef",
                       "ExternalEUtranCellFDD": external_eutrancell_ref,
                       "ExternalEUtranCellTDD": external_eutrancell_ref}
        try:
            user = get_workload_admin_user()
            cmd = "cmedit get {0} {1}".format(node_id, mo_ref_dict.get(mo_name))
            response = user.enm_execute(cmd)
            output = response.get_output()
            for line in output:
                if ("FDN " in line and not mo_name == 'EUtranCellRelation') or (
                        mo_name == 'EUtranCellRelation' and 'neighborCellRef' in line):
                    ref_value = "ManagedElement{0}".format(line.split(': ')[-1].split(",ManagedElement")[-1])
                    return ref_value
            raise EnmApplicationError(output)
        except Exception as e:
            raise EnmApplicationError("Could not retrieve {0} for node {1}, cannot create MCDBurst "
                                      "for MO: {2}, as no MO reference available. Error encountered: "
                                      "{3}".format(mo_ref_dict.get(mo_name), node_id, mo_name, str(e)))

    def create_external_enodeb_function(self, nodes=None, total_mos_required=1):
        """
        Create a range of ExternalENodeBFunction on the supplied nodes

        :param nodes: List of `load_node.Node` objects
        :type nodes: list
        :param total_mos_required: Total number of mos to be created
        :type total_mos_required: int
        """
        log.logger.debug("Creating ExternalENodeBFunction for use by MCDBursts.")
        nodes = nodes if nodes else self.get_nodes_list_by_attribute(node_attributes=["node_id", "subnetwork"])
        cmd = ("cmedit create {subnetwork},MeContext={node_id},ManagedElement=1,"
               "ENodeBFunction=1,EUtraNetwork=1,ExternalENodeBFunction={mo_name} ExternalENodeBFunctionId={mo_name}; "
               "{base_values}")
        user = get_workload_admin_user()
        self.TEARDOWN_OBJECTS.append(partial(picklable_boundmethod(self.delete_created_external_enodeb_function_mos),
                                             user, nodes))
        for node in nodes:
            node_cardinality = self.check_node_cardinality(user, node)
            if node_cardinality and (node_cardinality + total_mos_required) <= 512:
                for _ in xrange(total_mos_required):
                    mo_name = "CMSYNC-{0}-{0}".format(_)
                    try:
                        response = user.enm_execute(cmd.format(subnetwork=node.subnetwork, mo_name=mo_name,
                                                               node_id=node.node_id, base_values=ENODEB_VALUES))
                        self.update_created_mos(response.get_output(), node, mo_name)
                    except Exception as e:
                        log.logger.debug("\nFailed to create ExternalENodeBFunction for use by MCDBurst, error "
                                         "encountered: {0}.".format(str(e)))
        log.logger.debug("Completed creating ExternalENodeBFunction for use by MCDBursts.")

    @staticmethod
    def check_node_cardinality(user, node):
        """
        Check the existing ExternalENodeBFunction cardinality count on the supplied node

        :param user: User who will perform the ENM query
        :type user: `enm_user_2.User`
        :param node: Node which will be queried in ENM
        :type node: `load_node.LoadNodeMixin`

        :return: Split output of the cmedit check
        :rtype: int
        """
        cmd = "cmedit get {0} ExternalENodeBFunction -cn".format(node.node_id)
        try:
            response = user.enm_execute(cmd)
            mo_count = response.get_output()[-1].split(' ')[0]
            if mo_count.isdigit() and int(mo_count) < 512:
                return int(mo_count)
            else:
                log.logger.debug("Maximum MO Cardinality for node: {0}, already reached, cannot create MO.".format(
                    node.node_id))
        except Exception as e:
            log.logger.debug("Unable to determine MO Cardinality for node: {0}, error encountered: [{1}]".format(
                node.node_id, str(e)))

    @staticmethod
    def update_created_mos(output, node, mo_name):
        """
        Validate the create command and add to the list of created MOs

        :param output: Response from ENM
        :type output: list
        :param node: Node the MO was created under
        :type node: `load_node.LoadNode`
        :param mo_name: Name of the MO to append to the list of created
        :type mo_name: str
        """
        global CREATED_EXTERNAL_ENODEB_FUNCTION_MOS
        if (any(ONE_INSTANCE_VERIFICATION in line for line in output) or
                any("already exists" in line for line in output)):
            if node.node_id not in CREATED_EXTERNAL_ENODEB_FUNCTION_MOS.keys():
                CREATED_EXTERNAL_ENODEB_FUNCTION_MOS[node.node_id] = []
            CREATED_EXTERNAL_ENODEB_FUNCTION_MOS[node.node_id].append(
                "ManagedElement=1,ENodeBFunction=1,EUtraNetwork=1,ExternalENodeBFunction={0}".format(mo_name))
        else:
            log.logger.debug("\nFailed to create ExternalENodeBFunction response: {0}.".format(output))

    def delete_created_external_enodeb_function_mos(self, user, nodes):
        """
        Delete any created ExternalENodeBFunction

        :param user: User who will perform the ENM query
        :type user: `enm_user_2.User`
        :param nodes: List of `load_node.Node` objects
        :type nodes: list
        """
        log.logger.debug("Deleting ExternalENodeBFunction created for use by MCDBursts.")
        for node in nodes:
            if (node.node_id in CREATED_EXTERNAL_ENODEB_FUNCTION_MOS.keys() and
                    CREATED_EXTERNAL_ENODEB_FUNCTION_MOS.get(node.node_id)):
                try:
                    cmd = ("cmedit delete {node_id} ExternalENodeBFunction=CMSYNC* -ALL".format(node_id=node.node_id))
                    user.enm_execute(cmd)
                    log.logger.debug("Completed deleting ExternalENodeBFunction created for use by MCDBursts.")
                except Exception as e:
                    log.logger.debug("\nFailed to delete ExternalENodeBFunction for use by MCDBurst, error encountered:"
                                     " {0}.".format(str(e)))
                    self.add_error_as_exception(e)


class CmSyncSetupFlow(CmSyncFlow):
    BURST_TYPE = "AVC"

    def execute_flow(self):
        """
        Executes the flow for the profile
        """
        self.state = "RUNNING"
        users = self.create_profile_users(self.NUM_USERS, self.USER_ROLES)
        while self.keep_running():
            try:
                network_mo_info = NetworkMoInfo(users[0])
                network_mo_info.map_ne_types_to_mediator_and_update_mo_count()
                cmsync_mo_info = CmSyncMoInfo(users[0], network_mo_info.mediator_dict, network_mo_info.network_mo_count,
                                              mscm_ratio=self.MSCM_RATIO, mscmce_ratio=self.MSCMCE_RATIO,
                                              max_mos_per_rnc=self.MAX_MOS_PER_RNC, max_mos_mscmce=self.MAX_MOS_MSCMCE,
                                              values_per_profile=self.VALUES_PER_PROFILE)
                cmsync_mo_info.set_values_for_all_profiles()
                cmsync_mo_info.set_profile_node_allocations_values()
                persistence.set(PROFILE_NOTIFICATION_VALUES, cmsync_mo_info.profile_notification_calculations, -1)
                persistence.set(PROFILE_NODE_ALLOCATION_VALUES, cmsync_mo_info.profile_node_allocations, -1)
                self.log_network_cell_info(cmsync_mo_info)
            except Exception as e:
                self.add_error_as_exception(e)
            self.sleep()

    @staticmethod
    def log_network_cell_info(cmsync_mo_info):
        """
        Logs the relevant notification information to the profile's log

        :param cmsync_mo_info: Instance to be accessed, in order to log the current notification information
        :type cmsync_mo_info: `network_cell_info.NetworkCellInfo`
        """
        for key, value in cmsync_mo_info.mediator_dict.iteritems():
            log.logger.info("Total cell values for {0}:".format(key))
            log.logger.info("{0}".format(value))
            log.logger.info("")
        log.logger.info("Total Cell Count: {0}\n".format(cmsync_mo_info.network_mo_count))
        log.logger.info("Percentage MSCM Count: {0}".format(cmsync_mo_info.get_network_percentage_for_mediator("MSCM")))
        log.logger.info("Percentage MSCMCE Count: {0}".format(cmsync_mo_info.
                                                              get_network_percentage_for_mediator("MSCMCE")))
        log.logger.info("")
        log.logger.debug("\nTotal notifications to be generated per day: {0}"
                         .format(cmsync_mo_info.total_notifications))
        log.logger.debug("{0}".format(cmsync_mo_info.calculate_notification_per_profile_per_day()))
        for key, value in cmsync_mo_info.profile_node_allocations.iteritems():
            log.logger.info("Profile Node Allocation: {0}:".format(key))
            log.logger.info("{0}".format(value))
        log.logger.info("")
        for key, value in cmsync_mo_info.profile_notification_calculations.iteritems():
            log.logger.info("Profile Notification Values: {0}:".format(key))
            log.logger.info("{0}".format(value))
        log.logger.info("")


class CMSync32Flow(CmSyncFlow):
    UPDATED_AVG_PER_NODE = 0
    BURST_TYPE = "AVC"

    def calculate_total_per_second_for_gerancells(self, total_available_nodes):
        """
        Determine the basic rate to be generated based upon the total number of available GeranCell

        :param total_available_nodes: Total number of nodes to generate the notification across
        :type total_available_nodes: int
        :return: Total rate per second to be applied across all BSC nodes
        :rtype: int
        """
        cmd = "cmedit get * GeranCell -cn"
        user = get_workload_admin_user()
        response = user.enm_execute(cmd)
        if response and response.get_output() and str(response.get_output()[-1]).split(' ')[0].isdigit():
            cell_count = int(str(response.get_output()[-1]).split(' ')[0])
            log.logger.debug("Calculating rate per second, per node, based on inputs base rate: {0} * total cells: {1} "
                             "/ total BSCs: {2}.".format(self.AVG_PER_CELL_PER_SEC, cell_count, total_available_nodes))
            total_rate = round((cell_count * self.AVG_PER_CELL_PER_SEC) / total_available_nodes, 3)
            log.logger.debug("Notification rate per second, per node, determined to be {0}.".format(total_rate))
            return total_rate
        else:
            log.logger.debug("Unable to determine total GeranCells on deployment continuing with basic load rate.")
            return self.AVG_PER_CELL_PER_SEC

    def execute_flow(self):
        """
        Executes the profile flow.
        """
        self.state = "RUNNING"
        allocated_nodes = self.get_nodes_list_by_attribute(
            node_attributes=["node_id", "netsim", "simulation", "primary_type", "node_name", "lte_cell_type"])
        available_nodes = generate_basic_dictionary_from_list_of_objects(allocated_nodes, "primary_type")
        while self.keep_running():
            if self.NAME == "CMSYNC_32":
                try:
                    self.UPDATED_AVG_PER_NODE = self.calculate_total_per_second_for_gerancells(
                        len(available_nodes.get("BSC")))
                except Exception as e:
                    self.add_error_as_exception(e)
                    log.logger.debug("Unable to determine total GeranCells on deployment continuing with basic load "
                                     "rate.")
                    self.UPDATED_AVG_PER_NODE = self.AVG_PER_CELL_PER_SEC
            total_expected = self.calculated_daily_expected_load(
                sum([len(nodes) for nodes in available_nodes.values()]))
            ts = timestamp.get_human_readable_timestamp()
            update_cm_ddp_info_log_entry(self.NAME, "{0} {1} {2}\n".format(ts, self.NAME, total_expected))
            try:
                self.create_mo_types(available_nodes)
                self.sleep()
            except KeyboardInterrupt as e:
                self.teardown_list.extend(self.TEARDOWN_OBJECTS)
                raise e
            self.TEARDOWN_OBJECTS = []
            del self.teardown_list[:]

    def create_mo_types(self, available_nodes):
        """
        Creates the MO type objects

        :param available_nodes: Dictionary of the nodes, available to the profile
        :type available_nodes: dict
        """
        mo_types = []
        for mo_burst_info in self.NOTIFICATION_INFO:
            # Select nodes per the NeType required by the notification
            nodes = available_nodes.get(mo_burst_info["node_type"])
            if nodes:
                log.logger.debug("BURST INFO - Burst id: {burst_id}, Total Available {type} nodes: {num_available};"
                                 " mo info: {mo_info}".format(burst_id=self.burst_id, num_available=len(nodes),
                                                              type=mo_burst_info["node_type"], mo_info=mo_burst_info))
                required_rate = len(nodes) * self.UPDATED_AVG_PER_NODE
                # Determine the different MOtypes required to locate the MOs on the assigned nodes
                mo_types.extend(netsim_mo.determine_mo_types_required_with_avc_burst_info(mo_burst_info=mo_burst_info,
                                                                                          nodes=nodes,
                                                                                          required_rate=required_rate))
        self.create_burst_objects(mo_types)

    def create_burst_objects(self, mo_types):
        """
        Creates the AVC burst objects

        :param mo_types: List of the MOType objects
        :type mo_types: list
        """
        # Based on the supplied information build the list of AVCBursts objects
        for mo_type in mo_types:
            # Create the burst and add the burst to the teardown list
            burst = AVCBurst(nodes=mo_type.nodes, burst_id=self.burst_id, duration=self.BURST_DURATION,
                             burst_rate=mo_type.notification_rate, mo_path=mo_type.mo_path,
                             mo_attribute=mo_type.mo_attribute, mo_values=mo_type.mo_values,
                             notification_rate=self.UPDATED_AVG_PER_NODE)
            self.start_bursts([burst])

    def calculated_daily_expected_load(self, total_nodes):
        """
        Determine the daily expected load for the respective profile

        :param total_nodes: Total number of nodes to be used in the notifications
        :type total_nodes: int

        :return: Total daily expected notifications
        :rtype: int
        """
        notifications_per_duration = self.BURST_DURATION * self.UPDATED_AVG_PER_NODE
        daily_execution = 86400 / self.SCHEDULE_SLEEP
        return total_nodes * notifications_per_duration * daily_execution


class CMSync23Flow(CMSync32Flow):

    def execute_flow(self):
        """
        Executes the profile flow
        """
        self.modify_existing_notification_info()
        super(CMSync23Flow, self).execute_flow()

    def modify_existing_notification_info(self):
        """
        Modify the hardcoded rate in the profile_cmds value (if present)
        """
        notification_dict = {}
        for notification in self.NOTIFICATION_INFO:
            notification["notification_percentage_rate"] = 0.5
            notification_dict[notification["node_type"]] = [notification]
        setattr(self, 'NOTIFICATION_INFO', notification_dict)

    def create_mo_types(self, available_nodes):
        """
        Creates the MO type objects

        :param available_nodes: Dictionary of the nodes, available to the profile
        :type available_nodes: dict
        """
        mo_types = []
        total_nodes = sum([len(node_list) for node_list in available_nodes.values()])
        self.UPDATED_AVG_PER_NODE = (self.NOTIFICATION_PER_SECOND / total_nodes if total_nodes else
                                     self.NOTIFICATION_PER_SECOND)
        for ne_type in self.NOTIFICATION_INFO.keys():
            mo = self.NOTIFICATION_INFO.get(ne_type)[0].get('mo_type_name')
            nodes = available_nodes.get(ne_type)
            if nodes:
                mo_types.extend(self.get_mo_types(ne_type, mo, nodes, self.UPDATED_AVG_PER_NODE))
        self.create_burst_objects(mo_types)


class CMSync15Flow(CMSync32Flow):

    def calculate_avg_per_node(self):
        """
        Calculate the avg per node based on the below comment from TERE team:

         - For CMSync_15, the requirement of 0.003 notifications per Router6672 node per second is based on a
         - 5k Router6672 network. Our profile needs to calculate how many Router6672 nodes we have in our network
         - and apply a dynamic rate. For example, if we are running across 1k Router Nodes in our 5k Transport,
         - our rate will be 1000 Router6672 nodes which will generate 15/1000 = 0.015 notifications per
         - second per node (.003 X 5000) = 15.

        :return: Returns the avg per nodes based on the number of allocated nodes
        :rtype: float
        """
        allocated_nodes = self.get_nodes_list_by_attribute()
        log.logger.debug("Calculating the average rate per, total allocated node(s): [{0}]".format(allocated_nodes))
        rate = (self.ROUTER_SUPPORT * 0.003) / float(len(allocated_nodes)) if allocated_nodes else 0
        log.logger.debug("Calculated rate to be {0}.".format(rate))
        return round(rate, 5)

    def execute_flow(self):
        """
        Executes the profile flow
        """
        self.UPDATED_AVG_PER_NODE = self.calculate_avg_per_node()
        super(CMSync15Flow, self).execute_flow()


class CollectionSyncFlow(GenericFlow):
    NAME = None
    NODE_TYPE = None
    TIMEOUT = None
    MSG = None
    COLLECTION_NAME = None

    @staticmethod
    def create_cm_management_object(nodes=None, user=None, collections=None):
        """
        Create the management object to perform the synchronise

        :param nodes: List of enm_node instances
        :type nodes: list
        :param user: ENM user who perform the sync operation
        :type user: `enm_user_2.User`
        :param collections: List of ENM collection instances
        :type collections: list

        :raises EnmApplicationError: raised if their is an exception retrieving the management object

        :return: CmManagement instance which will perform the sync
        :rtype: `CmManagement`
        """
        try:
            cm_management_object = CmManagement.get_management_obj(nodes=nodes, user=user, collections=collections)
            return cm_management_object
        except Exception as e:
            raise EnmApplicationError(str(e))

    def execute_flow(self):
        """
        Executes the profile flow
        """
        user = self.create_profile_users(1, ["ADMINISTRATOR"])[0]
        nodes = self.get_nodes_list_by_attribute()

        self.state = 'RUNNING'
        collection = None
        self.COLLECTION_NAME = "{0}_collection_{1}_{2}".format(self.NAME, self.NODE_TYPE,
                                                               arguments.get_random_string(size=4))
        while self.keep_running():
            self.sleep_until_next_scheduled_iteration()
            if not self.check_if_collection_exists(user):
                try:
                    # create a collection instance
                    collection = self.create_collection(user, nodes)
                except Exception as e:
                    self.add_error_as_exception(e)
                    continue
            cm_management = self.create_cm_management_object(collections=[collection])
            # synchronize
            try:
                cm_management.synchronize(timeout=self.TIMEOUT)
                log.logger.debug("Successfully synched nodes in the collection")
            except Exception as e:
                self.add_error_as_exception(e)

    def sleep_exception(self, exception, sleep_time):
        """
        Exception clause to sleep for given seconds and output failed to create collection

        :param exception: Name of exception
        :type exception: Exception

        :param sleep_time: Seconds to sleep for
        :type sleep_time: Integer
        """

        log.logger.debug("Failed to create collection, sleeping for {0} seconds before retrying.".format(
            sleep_time))
        self.add_error_as_exception(exception)
        time.sleep(sleep_time)

    def check_if_collection_exists(self, user):
        """
        Check if the collection is in the list returned by the collection command

        :param user: User who will create the collection in ENM
        :type user: `enm_user_2.User`

        :return: Boolean if the collection name is matched
        :rtype: bool
        """
        log.logger.debug("Checking if collection {0} exists.".format(self.COLLECTION_NAME.lower()))
        exists = False
        try:
            cmd = "collection list -t"
            response = user.enm_execute(cmd)
            output = response.get_output()
            if output:
                for line in output:
                    values = line.encode('utf-8').strip().split()
                    if values and self.COLLECTION_NAME.lower() == values[0].lower():
                        exists = True
            return exists
        except Exception as e:
            log.logger.debug("Could not retrieve collection list from ENM CLI, error encountered: {0}".format(str(e)))

    def create_collection(self, user, nodes):
        """
        Create the collection on ENM

        :param user: User who will create the collection in ENM
        :type user: `enm_user_2.User`
        :param nodes: List of nodes to be included in the collection
        :type nodes: list

        :return: Created collection instance
        :rtype: `netex.Collection`
        """
        collection = Collection(user=user, name=self.COLLECTION_NAME, nodes=nodes)
        while not collection.exists:
            try:
                log.logger.debug("Collection not found, creating collection : {0}.".format(self.COLLECTION_NAME))
                collection.create()
                teardown_collection = Collection(user=user, name=self.COLLECTION_NAME, nodes=[])
                teardown_collection.id = collection.id
                self.teardown_list.append(teardown_collection)
                # Sleep for 2 seconds to allow the creation to be reflected in persistence
                time.sleep(2)
            except Exception as e:
                self.sleep_exception(e, 300)
        return collection


class CMSync25Flow(CollectionSyncFlow):
    NODE_TYPE = "RadioNode"


class CMSync30Flow(CollectionSyncFlow):
    NODE_TYPE = "ERBS"


class CMSync33Flow(CollectionSyncFlow):
    NODE_TYPE = "Router6672"


class CMSync34Flow(CollectionSyncFlow):
    NODE_TYPE = "MLTN"
    TIMEOUT = 60 * 15


class CMSync35Flow(CollectionSyncFlow):
    NODE_TYPE = "BSC"
    TIMEOUT = 60 * 45


class CMSync39Flow(CollectionSyncFlow):
    NODE_TYPE = "EPG_OI"


class CMSync40Flow(CollectionSyncFlow):
    NODE_TYPE = "CCDM"


class CMSync24Flow(CollectionSyncFlow):
    NODE_TYPE = "RadioNode"
    MSG = "Successfully synched all RadioNodes."

    def execute_flow(self):
        """
        Executes the profile flow
        """
        self.state = 'RUNNING'
        try:
            self.create_cm_management_object().synchronize(netype=self.NODE_TYPE, timeout=self.TIMEOUT)
            log.logger.debug(self.MSG)
        except Exception as e:
            self.add_error_as_exception(e)


class CMSyncProfile(CollectionSyncFlow):
    def execute_flow(self):
        """
        Executes the flow for the profile
        """
        self.state = "RUNNING"

        log.logger.debug("Starting the CMSync - execute sync and exchange nodes flow.")

        while self.keep_running():
            self.sleep_until_next_scheduled_iteration()

            nodes = self.get_nodes_list_by_attribute()
            if nodes and len(nodes) >= 1:
                cm_management = self.create_cm_management_object(nodes=nodes)
                try:
                    cm_management.synchronize()
                except Exception as e:
                    self.add_error_as_exception(e)
            else:
                self.add_error_as_exception(EnvironError("No node assigned to profile to Sync as expected"))
            self.exchange_nodes()

        log.logger.debug("Finishing the CMSync - execute sync and exchange nodes flow.")
